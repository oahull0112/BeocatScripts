# -*- coding: utf-8 -*-
"""
Created on Mon Mar 25 17:09:37 2019

@author: olivia

Measure distance as a function of time for two atoms in an ehrenfest dynamics simulation
"""


from __future__ import division
import csv
import numpy as np
from scipy.fftpack import fft, fftfreq
#matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
#import matplotlib.axes as ax
import sys
from mpl_toolkits import mplot3d

filename='test'


def get_nuc_coords(filename):
    ''' Pull the nuclear coordinates from an ehrenfest dynamics calculation in Gaussian
    input: filename (string)
    output: coordinate file, csv format.
    Name of coordinate file is "filename_nc.csv" '''
    
    count = 1
    coord_lines = [count]
    
    with open(filename, 'r') as f:
        for line in f:
            if ("Number     Number       Type             X           Y           Z" in line):
                next(f)
                coord = next(f)
                while True:
                    if coord[1] == '-': # signals end of coordinate lines
                        count += 1
                        coord_lines.append(count)
                        break
                    else:
                        coord_lines.append([coord.split()[1], coord.split()[3], coord.split()[4], coord.split()[5]])
                        coord = next(f)
                        
    
    '''Now all of the coordinate data is in coord_lines'''
    
    
def view_coords(coord_lines):
    
    '''PUT LINES TO LOAD IN DATA HERE
    coord_lines = 
    '''
    ax = plt.axes(projection='3d')
    
    
    x_coords = []
    y_coords = []
    z_coords = []
    i = 0
    while i < len(coord_lines):
        if type(coord_lines[i]) == int:
            i = i+1
            '''PLOT STUFF'''
            #ax.scatter3D(xdata, ydata,zdata, c=zdata, cmap='Greens')
            #plt.cla()
            ax.set_xlim3d(-10, 10)
            ax.set_ylim3d(-10,10)
            ax.set_zlim3d(-10,10)
            ax.scatter3D(x_coords, y_coords, z_coords, depthshade=False)
            plt.title('step = ' + str(i))
            plt.pause(.001)
            x_coords = []; y_coords = []; z_coords = []
        else:
            x_coords.append(float(coord_lines[i][1]))
            y_coords.append(float(coord_lines[i][2]))
            z_coords.append(float(coord_lines[i][3]))
        i = i + 1
    
def getSmallMoleculeDistance(coord_lines):
    pos1 = 9 # 9th position in coord list
    pos2 = 10 # 10th position in coord list
    
    i = 0
    while type(coord_lines[i+1]) == list:
        i = i+1
    
    nA = i # number of atoms
   
    x1 = []
    x2 = []
    
    y1 = []
    y2 = []
    
    z1 = []
    z2 = []
    
    '''
    the index will be the number of atoms plus the pos1, pos2 to get the next time step of that coordinate.
    So the incrementer will be the number of atoms
    And the starting points will be pos1, pos2 (+ 1 to offset the first time entry)
    
    One we have x_i, y_i, z_i at each time step, then we can use euclidean distance formula to get distance.
    We can also run a separate indexer called t that increases by 1  during each loop to get the number of time steps
    then do a "range(t)" command to be able to plot the result against time.
    '''
    
